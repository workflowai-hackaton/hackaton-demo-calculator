#!/usr/bin/env python3
"""
GitHub Agent: Create or Update Issue from Repository Dispatch Payload
This script creates a new GitHub issue or updates an existing one.
"""

import argparse
import json
import os
import sys
import urllib.request
import urllib.error
from typing import Dict, Any, Tuple, Optional, List


def set_output(name: str, value: str) -> None:
    """Set GitHub Actions output variable."""
    github_output = os.environ.get("GITHUB_OUTPUT")
    if github_output:
        with open(github_output, "a", encoding="utf-8") as f:
            f.write(f"{name}={value}\n")


def log_error(message: str) -> None:
    """Log error message to stderr."""
    github_step_summary = os.environ.get("GITHUB_STEP_SUMMARY")
    if github_step_summary:
        with open(github_step_summary, "a", encoding="utf-8") as f:
            f.write(f"## âŒ Error\n\n{message}\n\n")


def gh_api(
    url: str,
    method: str = "GET",
    token: Optional[str] = None,
    body: Optional[Dict[str, Any]] = None
) -> Tuple[int, Optional[Dict[str, Any]]]:
    """Make a GitHub API request using urllib."""
    req = urllib.request.Request(url, method=method)
    req.add_header("Accept", "application/vnd.github+json")
    req.add_header("X-GitHub-Api-Version", "2022-11-28")
    
    if token:
        req.add_header("Authorization", f"Bearer {token}")
    
    data = None
    if body is not None:
        data = json.dumps(body).encode("utf-8")
        req.add_header("Content-Type", "application/json")
    
    try:
        with urllib.request.urlopen(req, data=data, timeout=60) as resp:
            charset = resp.headers.get_content_charset() or "utf-8"
            txt = resp.read().decode(charset)
            return resp.getcode(), json.loads(txt) if txt else {}
    except urllib.error.HTTPError as e:
        err_txt = e.read().decode("utf-8", errors="replace")
        log_error(f"GitHub API error {e.code} for {method} {url}:\n```\n{err_txt}\n```")
        return e.code, None
    except Exception as e:
        log_error(f"Request failed for {method} {url}: {str(e)}")
        return 0, None


def format_acceptance_criteria(criteria: Any) -> str:
    """Format acceptance criteria as markdown list."""
    if isinstance(criteria, list):
        return "\n".join([f"- {item}" for item in criteria])
    elif isinstance(criteria, str):
        return criteria
    else:
        return "No acceptance criteria provided."


def build_issue_body(payload: Dict[str, Any]) -> Tuple[str, str]:
    """Build issue title and body from payload."""
    task_id = payload.get("task_id", "N/A")
    title = payload.get("title") or f"Agent Task {task_id}".strip()
    summary = payload.get("summary") or "No summary provided."
    acceptance = payload.get("acceptance_criteria") or "No acceptance criteria provided."
    base = payload.get("base") or "main"
    focus_paths = payload.get("focus_paths") or []
    stack_hint = payload.get("stack_hint") or ""
    extra = payload.get("extra") or {}
    
    lines = [
        f"**Task ID:** `{task_id}`",
        "",
        "## ðŸ“‹ Summary",
        summary,
        "",
        "## âœ… Acceptance Criteria",
        format_acceptance_criteria(acceptance),
        "",
        "## ðŸ” Context",
        f"- **Base branch:** `{base}`"
    ]
    
    if focus_paths:
        paths_str = ", ".join([f"`{p}`" for p in focus_paths])
        lines.append(f"- **Focus paths:** {paths_str}")
    
    if stack_hint:
        lines.append(f"- **Stack hint:** {stack_hint}")
    
    if "related_issues" in extra:
        lines.append(f"- **Related issues:** {extra['related_issues']}")
    
    if "links" in extra:
        lines.append(f"- **Links:** {extra['links']}")
    
    for key, value in extra.items():
        if key not in ["related_issues", "links"]:
            lines.append(f"- **{key.replace('_', ' ').title()}:** {value}")
    
    lines.extend([
        "",
        "## ðŸš€ How to Proceed",
        "1. **GitHub Copilot Workspace:** Use Copilot Workspace from this issue to generate a plan and open a PR",
        "2. **GitHub Copilot Chat:** Ask *\"Plan and implement this task with tests\"* and iterate",
        "3. **Manual Implementation:** Review the requirements and create a PR with your changes",
        "",
        "## ðŸ“ Notes",
        "- This issue was created/updated automatically by the agent workflow",
        "- Please update the issue with progress and link any related PRs",
        "",
        "---",
        "*Generated by GitHub Agent* ðŸ¤–"
    ])
    
    body = "\n".join(lines)
    return title, body


def add_copilot_comment(
    owner: str,
    repo: str,
    issue_number: int,
    token: str,
    custom_message: Optional[str] = None
) -> bool:
    """Add a comment to trigger Copilot on the issue."""
    if custom_message:
        comment_body = custom_message
    else:
        comment_body = (
            "ðŸ¤– **Agent Task Assignment**\n\n"
            "@copilot Please help implement this task. "
            "Generate a plan with the acceptance criteria above and suggest an implementation approach.\n\n"
            "Focus on:\n"
            "- Breaking down the task into manageable steps\n"
            "- Identifying files that need changes\n"
            "- Suggesting test cases\n"
        )
    
    url = f"https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/comments"
    status, resp = gh_api(url, method="POST", token=token, body={"body": comment_body})
    
    return status == 201


def update_issue_labels(
    owner: str,
    repo: str,
    issue_number: int,
    token: str,
    labels: List[str]
) -> bool:
    """Add labels to an existing issue."""
    url = f"https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/labels"
    status, resp = gh_api(url, method="POST", token=token, body={"labels": labels})
    
    return status == 200


def update_issue_assignees(
    owner: str,
    repo: str,
    issue_number: int,
    token: str,
    assignees: List[str]
) -> bool:
    """Add assignees to an existing issue."""
    url = f"https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/assignees"
    status, resp = gh_api(url, method="POST", token=token, body={"assignees": assignees})
    
    return status == 201


def update_existing_issue(
    owner: str,
    repo: str,
    issue_number: int,
    token: str,
    payload: Dict[str, Any]
) -> Tuple[bool, Optional[str]]:
    """Update an existing issue with agent task details."""
    url = f"https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}"
    status, current_issue = gh_api(url, method="GET", token=token)
    
    if status != 200 or not current_issue:
        log_error(f"Could not fetch issue #{issue_number}. Status: {status}")
        return False, None
    
    html_url = current_issue.get("html_url")
    
    if payload.get("update_body", False):
        title, body = build_issue_body(payload)
        update_payload = {"body": body}
        
        if payload.get("update_title", False):
            update_payload["title"] = title
        
        status, resp = gh_api(url, method="PATCH", token=token, body=update_payload)
        if status != 200:
            log_error(f"Failed to update issue body. Status: {status}")
    
    labels = payload.get("labels") or ["agent-task", "copilot-ready"]
    if labels:
        if not update_issue_labels(owner, repo, issue_number, token, labels):
            log_error(f"Failed to add labels to issue #{issue_number}")
    
    assignees = payload.get("assignees") or []
    if assignees:
        if not update_issue_assignees(owner, repo, issue_number, token, assignees):
            log_error(f"Failed to add assignees to issue #{issue_number}")
    
    if payload.get("mention_copilot", True):
        copilot_message = payload.get("copilot_message")
        if not add_copilot_comment(owner, repo, issue_number, token, copilot_message):
            log_error(f"Failed to add Copilot comment to issue #{issue_number}")
    
    return True, html_url


def create_github_issue(
    owner: str,
    repo: str,
    token: str,
    payload: Dict[str, Any]
) -> Tuple[bool, Optional[int], Optional[str]]:
    """Create a new GitHub issue and return success status, number, and URL."""
    title, body = build_issue_body(payload)
    
    labels = payload.get("labels") or ["agent-task", "copilot-ready"]
    assignees = payload.get("assignees") or []
    
    issue_payload = {
        "title": title,
        "body": body,
        "labels": labels
    }
    
    if assignees:
        issue_payload["assignees"] = assignees
    
    url = f"https://api.github.com/repos/{owner}/{repo}/issues"
    status, resp = gh_api(url, method="POST", token=token, body=issue_payload)
    
    if status == 201 and resp:
        number = resp.get("number")
        html_url = resp.get("html_url")
        
        if payload.get("mention_copilot", True):
            copilot_message = payload.get("copilot_message")
            add_copilot_comment(owner, repo, number, token, copilot_message)
        
        return True, number, html_url
    else:
        log_error(f"Failed to create issue. Status: {status}")
        return False, None, None


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Create or update a GitHub issue from agent task payload"
    )
    parser.add_argument(
        "--payload",
        required=True,
        help="Path to JSON payload file"
    )
    args = parser.parse_args()
    
    try:
        with open(args.payload, "r", encoding="utf-8") as f:
            payload = json.load(f)
    except FileNotFoundError:
        log_error(f"Payload file not found: {args.payload}")
        return 1
    except json.JSONDecodeError as e:
        log_error(f"Invalid JSON in payload: {str(e)}")
        return 1
    
    gh_repo = os.environ.get("GH_REPO")
    gh_token = os.environ.get("GH_TOKEN")
    
    if not gh_repo or not gh_token:
        log_error("Missing GH_REPO or GH_TOKEN environment variables")
        return 1
    
    try:
        owner, repo = gh_repo.split("/", 1)
    except ValueError:
        log_error(f"Invalid repository format: {gh_repo}")
        return 1
    
    existing_issue = payload.get("issue_number")
    
    if existing_issue:
        success, html_url = update_existing_issue(owner, repo, existing_issue, gh_token, payload)
        if success:
            set_output("issue_number", str(existing_issue))
            set_output("issue_url", html_url)
            set_output("action", "updated")
            return 0
        else:
            return 1
    else:
        success, number, html_url = create_github_issue(owner, repo, gh_token, payload)
        
        if success:
            set_output("issue_number", str(number))
            set_output("issue_url", html_url)
            set_output("action", "created")
            return 0
        else:
            return 1


if __name__ == "__main__":
    sys.exit(main())
